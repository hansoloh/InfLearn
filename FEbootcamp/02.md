- inline
  - 동일한 라인에 다른 요소와 함께 위치 가능
  - width height margin padding 지정 불가. 상하 여백은 line-height
  - inline 요소 안에 block 요소 포함할수 없음
  - span, a, strong, img, br, input, select, textarea, button etc
- display 프로퍼티로 inline <-> block 전환
- display:none; 해당 요소가 차지하는 공간까지 사라짐
- visibility:hidden; 해당 요소가 차지하는 공간은 남겨둠
- z-index; 큰 숫자값을 지정할수록 화면 전면에 출력
- overflow; 자식 요소가 부모 요소 영역 벗어났을때 처리 방법
  - visible hidden scroll auto
- float으로 설정한 요소는 display:block으로 됨 (display:flex 제외)
  - width는 inline-block처럼 요소의 크기만큼 width가 설정됨 (cf.block요소는 width가 100% 참고)
---
- js : proto type 기반 객체 지향 언어
  - 객체 생성 방법
    - 객체 리터럴;
    - 클래스 기반 객체 생성 문법(ES6)
    - new Object(); 참고
    - 생성자 함수; 참고
      - 객체이름.prototype.프로퍼티명=코드
      - User.prototype.message = function(){}
- this
  - 자신의 객체
  - 화살표 함수에서는 사용x
---
#### array
- slice join reverce concat push pop shift
- forEach; for문 대체, 간단히 배열의 각 아이템을 가져옴
- map; 배열의 각 요소에 함수식을 적용해서 그 결과값을 새로운 배열로 리턴
- indexOf; 찾고자 하는 데이터의 인덱스 번호를 리턴
- findIndex; 배열의 아이템이 객체일 경우? (indexOf쓰면 안나옴. -1 리턴) 해당 객체에서 찾고자 한 데이터의 인덱스 번호 리턴
- find; 데이터의 위치x 찾고자 하는 데이터가 들어있는 '객체' 자체를 리턴
- filter; 특정 조건에 맞는 아이템만 추출
---
#### 동기 비동기 promise callback
- (오래 걸리는 요청 or 요청에 에러났을 시 동기는 프로그램이 작동 안될수 있기 때문에 이를 방지하기 위해 )비동기 처리하여 동시에 다른 요청들도 처리할 수 있게 하기 위해? 비동기 사용.
- callback
- promise 객체 
  - promise.then(successCallback, failureCallback)
    - resolve; true
    - reject; false
    - pendding; 대기
  - then에 3가지 경우 실행될 함수 다 지정되어 있어야 정상 작동?
    - 조건이 false인데 resolve만 선언해놨을 경우 작동 안함. 결과 안찍힘
  - catch
    - promise 문에서 예외가 발생할 경우. resolve reject pendding이 다 아닐 경우? 어떤 경우임
    - then에 failureCallback이 정의되지 않았을 경우도 예외로 처리되어 reject시에 catch메서드 호출됨
  - throw

- 동기 처리 synchronous
  - 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식
  - 태스크를 순서대로 하나씩 처리. 실행 순서가 보장됨
  - 앞선 태스크가 종료될때까지 이후 태스크들이 블로킹됨..
- 비동기 처리 asynchronous
  - 현재 실행 중인 태스크가 종료되지 않은 상태여도 다음 태스크를 곧바로 실행하는 방식
  - setTimeout setInterval HTTP 요청, 이벤트 핸들러 등
  - callback 패턴 ; callback 함수 중첩으로 callback hell을 발생시켜 가독성 저하, 에러의 예외 처리 곤란, 여러 개의 비동기 처리 한 번에 처리하는데에도 한계 등의 문제.
  - 등을 해결하기 위해 promise ; callback 패턴이 가진 한계를 보완.
  - event loop/call stack/heap/task queue
    - new Promise로 객체 생성
    - 결과값 true false로 resolve, reject 함수 호출
    - then
      - 첫번째 callback : resolve
      - 두번째 callback : reject
        - 비동기 처리에서 발생한 에러 처리. 
        - 첫번째 비동기 처리에서 발생한 에러는 catch하지 못함
        - 코드 복잡해져 가독성 down
    - catch : reject인 경우 호출
      - 모든 then 메서드 호출 후 호출하면 비동기 처리에서 발생한 에러rejected + then메서드 내에서 발생한 에러까지 모두 catch!!
      - ~~then 두번째 callback~~ 말고 <u>***___catch 매서드 사용!!___***</u>
    - finally : resolve reject 여부에 관계없이 무조건 한번 호출됨. 프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용.
    - try-catch-fianlly 순  후속 처리 메서드 호출
    - 은 언제나 promise를 반환하므로 연속 호출 가능. 먼소리야 : promise chaining
    - callback 가독성 문제 해결하기 위해 async/await
---
- data-position="0"