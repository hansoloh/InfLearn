- js : proto type 기반 객체 지향 언어
  - 객체 생성 방법
    - 객체 리터럴;
    - 클래스 기반 객체 생성 문법(ES6)
    - new Object(); 참고
    - 생성자 함수; 참고
      - 객체이름.prototype.프로퍼티명=코드
      - User.prototype.message = function(){}
- this
  - 자신의 객체
  - 화살표 함수에서는 사용x
---

#### array
- slice join reverce concat push pop shift
- forEach; for문 대체, 간단히 배열의 각 아이템을 가져옴
- map; 배열의 각 요소에 함수식을 적용해서 그 결과값을 새로운 배열로 리턴
- indexOf; 찾고자 하는 데이터의 인덱스 번호를 리턴
- findIndex; 배열의 아이템이 객체일 경우? (indexOf쓰면 안나옴. -1 리턴) 해당 객체에서 찾고자 한 데이터의 인덱스 번호 리턴
- find; 데이터의 위치x 찾고자 하는 데이터가 들어있는 '객체' 자체를 리턴
- filter; 특정 조건에 맞는 아이템만 추출
---

#### 동기 비동기 promise callback
- (오래 걸리는 요청 or 요청에 에러났을 시 동기는 프로그램이 작동 안될수 있기 때문에 이를 방지하기 위해 )비동기 처리하여 동시에 다른 요청들도 처리할 수 있게 하기 위해? 비동기 사용.
- callback
- promise 객체 
  - promise.then(successCallback, failureCallback)
    - resolve; true
    - reject; false
    - pendding; 대기
  - then에 3가지 경우 실행될 함수 다 지정되어 있어야 정상 작동?
    - 조건이 false인데 resolve만 선언해놨을 경우 작동 안함. 결과 안찍힘
  - catch
    - promise 문에서 예외가 발생할 경우. resolve reject pendding이 다 아닐 경우? 어떤 경우임
    - then에 failureCallback이 정의되지 않았을 경우도 예외로 처리되어 reject시에 catch메서드 호출됨
  - throw

- 동기 처리 synchronous
  - 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식
  - 태스크를 순서대로 하나씩 처리. 실행 순서가 보장됨
  - 앞선 태스크가 종료될때까지 이후 태스크들이 블로킹됨..
- 비동기 처리 asynchronous
  - 현재 실행 중인 태스크가 종료되지 않은 상태여도 다음 태스크를 곧바로 실행하는 방식
  - setTimeout setInterval HTTP 요청, 이벤트 핸들러 등
  - callback 패턴 ; callback 함수 중첩으로 callback hell을 발생시켜 가독성 저하, 에러의 예외 처리 곤란, 여러 개의 비동기 처리 한 번에 처리하는데에도 한계 등의 문제.
  - 등을 해결하기 위해 promise ; callback 패턴이 가진 한계를 보완.
  - event loop/call stack/heap/task queue
    - new Promise로 객체 생성
    - 결과값 true false로 resolve, reject 함수 호출
    - then
      - 첫번째 callback : resolve
      - 두번째 callback : reject
        - 비동기 처리에서 발생한 에러 처리. 
        - 첫번째 비동기 처리에서 발생한 에러는 catch하지 못함
        - 코드 복잡해져 가독성 down
    - catch : reject인 경우 호출
      - 모든 then 메서드 호출 후 호출하면 비동기 처리에서 발생한 에러rejected + then메서드 내에서 발생한 에러까지 모두 catch!!
      - ~~then 두번째 callback~~ 말고 <u>***___catch 매서드 사용!!___***</u>
    - finally : resolve reject 여부에 관계없이 무조건 한번 호출됨. 프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용.
    - try-catch-fianlly 순  후속 처리 메서드 호출
    - 은 언제나 promise를 반환하므로 연속 호출 가능. 먼소리야 : promise chaining
    - callback 가독성 문제 해결하기 위해 async/await
---

- event.target; 실제 이벤트가 발생하는 요소. 버블링 최하위 요소를 리턴. 내가 클릭한 ***자식*** 요소 리턴. 실제 클릭한 부분. 더 작은 범위.
- event.currentTarget (=this); 이벤트가 처리되고 있는 DOM 요소 (현재 대상). 이벤트 핸들러가 부착된 ***부모***의 위치 리턴. 이벤트가 바인딩된 요소. addEventListener 앞에 기술된 객체.
- e.preventDefaul(); 기본 속성 동작 중단.
---
- babel; ES6 최신 문법을 지원하지 않는 브라우저에서도 자바스크립트 코드가 잘 작동하도록 최신 문법 -> 기존 문법으로 자동으로 변환해줌
  - `<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.24.0/babel.js"></script>`  
  - `<script type= "text/babel" src="../js/main.js"></script>`